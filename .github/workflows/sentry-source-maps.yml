name: sentry-source-maps

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      nonce:
        description: "Unique nonce to force a distinct manual run"
        required: false
        default: ""

permissions:
  contents: read

jobs:
  build-and-upload:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Derive Sentry slugs (if missing)
        id: derive-slugs
        env:
          SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
          SENTRY_PROJECT: ${{ secrets.SENTRY_PROJECT }}
        run: |
          set -euo pipefail
          if [ -n "$SENTRY_ORG" ] && [ -n "$SENTRY_PROJECT" ]; then
            echo "Using provided SENTRY_ORG/SENTRY_PROJECT secrets";
            echo "org=$SENTRY_ORG" >> $GITHUB_OUTPUT
            echo "project=$SENTRY_PROJECT" >> $GITHUB_OUTPUT
            exit 0
          fi
          if [ -z "${SENTRY_DSN:-}" ]; then
            echo "SENTRY_DSN not set; cannot derive"; exit 0; fi
          if ! echo "$SENTRY_DSN" | grep -Eq 'https://[^@]+@o[0-9]+\.ingest\.[^/]+/[0-9]+'; then
            echo "DSN pattern unexpected; skipping"; exit 0; fi
          org_id=$(echo "$SENTRY_DSN" | grep -o 'o[0-9]*' | head -1 | sed 's/^o//')
          project_id=$(echo "$SENTRY_DSN" | sed -E 's@.*/([0-9]+)$@\1@')
          echo "Numeric org id: $org_id project id: $project_id"
          if [ -z "${SENTRY_AUTH_TOKEN:-}" ]; then
            echo "SENTRY_AUTH_TOKEN missing; cannot resolve slugs"; exit 0; fi
          # Ensure jq present
          if ! command -v jq >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y jq; fi
          orgs_json=$(curl -sf -H "Authorization: Bearer $SENTRY_AUTH_TOKEN" https://sentry.io/api/0/organizations/ || true)
          [ -z "$orgs_json" ] && { echo "Failed org fetch"; exit 0; }
          org_slug=$(echo "$orgs_json" | jq -r ".[] | select(.id==\"$org_id\") | .slug" | head -1)
          [ -z "$org_slug" ] && { echo "Org id map failed"; exit 0; }
          projects_json=$(curl -sf -H "Authorization: Bearer $SENTRY_AUTH_TOKEN" https://sentry.io/api/0/organizations/$org_slug/projects/ || true)
          [ -z "$projects_json" ] && { echo "Failed project fetch"; exit 0; }
          project_slug=$(echo "$projects_json" | jq -r ".[] | select(.id==\"$project_id\") | .slug" | head -1)
          [ -z "$project_slug" ] && { echo "Project id map failed"; exit 0; }
          echo "Resolved org slug: $org_slug project slug: $project_slug"
          echo "org=$org_slug" >> $GITHUB_OUTPUT
          echo "project=$project_slug" >> $GITHUB_OUTPUT
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
      - run: npm ci
      - name: Build (production)
        run: npm run build
        env:
          VITE_SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
      - name: Upload source maps
        if: success()
        run: |
          : "${SENTRY_ORG:=${DERIVED_ORG}}"
          : "${SENTRY_PROJECT:=${DERIVED_PROJECT}}"
          if [ -z "${SENTRY_AUTH_TOKEN}" ]; then echo "SENTRY_AUTH_TOKEN not set; skipping upload."; exit 0; fi
          if [ -z "${SENTRY_ORG}" ] || [ -z "${SENTRY_PROJECT}" ]; then echo "Slugs unresolved; skipping."; exit 0; fi
          if [ ! -d dist ]; then echo "dist directory missing (build step failed?)"; exit 1; fi
          map_count=$(find dist -type f -name '*.js.map' | wc -l | tr -d ' ')
          if [ "$map_count" = "0" ]; then echo "No .js.map files found in dist; aborting upload."; exit 1; fi
          echo "Creating Sentry release $GITHUB_SHA (org=$SENTRY_ORG project=$SENTRY_PROJECT)"
          npx @sentry/cli releases new "$GITHUB_SHA"
          # Attempt new sourcemaps command first; fallback to legacy upload-sourcemaps
          set +e
          upload_output=$(npx @sentry/cli sourcemaps upload --org "$SENTRY_ORG" --project "$SENTRY_PROJECT" --release "$GITHUB_SHA" --rewrite --url-prefix "~/assets" dist 2>&1)
          sc_status=$?
          if [ $sc_status -ne 0 ]; then
            echo "New 'sourcemaps upload' command failed or not available; falling back to legacy 'releases files upload-sourcemaps'." >&2
            upload_output=$(npx @sentry/cli releases files "$GITHUB_SHA" upload-sourcemaps dist --rewrite --url-prefix "~/assets" 2>&1 || true)
          fi
          set -e
          printf '%s\n' "$upload_output"
          # Parse lines: '> Found N files', '> Bundled N files', optional '(N files)' pattern
          found_count=$(echo "$upload_output" | sed -n 's/^> Found \([0-9]\+\) files.*/\1/p' | head -1)
          bundled_count=$(echo "$upload_output" | sed -n 's/^> Bundled \([0-9]\+\) files.*/\1/p' | head -1)
          [ -z "$bundled_count" ] && bundled_count=$(echo "$upload_output" | sed -n 's/^> Bundled \([0-9]\+\) files for upload.*/\1/p' | head -1)
          alt_count=$(echo "$upload_output" | sed -n 's/.*(\([0-9]\+\) files).*/\1/p' | head -1)
          final_upload_count=${bundled_count:-${found_count:-${alt_count:-0}}}
          [ -z "$final_upload_count" ] && final_upload_count=0
          echo "Detected upload file count (pre or post-bundle): ${final_upload_count}" || true
          echo "SENTRY_UPLOAD_BUNDLED_COUNT=${final_upload_count}" >> "$GITHUB_ENV"
          npx @sentry/cli releases finalize "$GITHUB_SHA"
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
          SENTRY_PROJECT: ${{ secrets.SENTRY_PROJECT }}
          DERIVED_ORG: ${{ steps.derive-slugs.outputs.org }}
          DERIVED_PROJECT: ${{ steps.derive-slugs.outputs.project }}
      - name: List uploaded Sentry release files (debug)
        if: success()
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG || steps.derive-slugs.outputs.org }}
          SENTRY_PROJECT: ${{ secrets.SENTRY_PROJECT || steps.derive-slugs.outputs.project }}
        run: |
          set -euo pipefail
          if [ -z "${SENTRY_AUTH_TOKEN}" ] || [ -z "${SENTRY_ORG}" ] || [ -z "${SENTRY_PROJECT}" ]; then
            echo "Missing auth or slugs; skipping list."; exit 0; fi
          echo "Listing files for release $GITHUB_SHA"
          npx @sentry/cli releases files "$GITHUB_SHA" list || echo "Listing failed (may be too early)."
      - name: Verify release in Sentry (strict mode)
        if: success()
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG || steps.derive-slugs.outputs.org }}
          SENTRY_PROJECT: ${{ secrets.SENTRY_PROJECT || steps.derive-slugs.outputs.project }}
          GIT_SHA: ${{ github.sha }}
          SENTRY_UPLOAD_BUNDLED_COUNT: ${{ env.SENTRY_UPLOAD_BUNDLED_COUNT }}
          # Allow manual override via workflow_dispatch inputs in future; default here.
          SENTRY_VERIFY_ATTEMPTS: 12
          SENTRY_VERIFY_INTERVAL_SEC: 5
        run: |
          set -euo pipefail
          : "${SENTRY_STRICT:=true}"
          : "${SENTRY_DEBUG:=false}"
          : "${SENTRY_FILE_FALLBACK:=true}"
          : "${SENTRY_UPLOAD_BUNDLED_COUNT:=0}"
          : "${SENTRY_VERIFY_ATTEMPTS:=12}"
          : "${SENTRY_VERIFY_INTERVAL_SEC:=5}"
          if [ -z "${SENTRY_AUTH_TOKEN}" ] || [ -z "${SENTRY_ORG}" ] || [ -z "${SENTRY_PROJECT}" ]; then
            echo "Missing auth or slugs; skipping verification"; exit 0; fi
          # Sanitize numeric env values
          echo "$SENTRY_VERIFY_ATTEMPTS" | grep -E '^[0-9]+$' >/dev/null 2>&1 || SENTRY_VERIFY_ATTEMPTS=12
          echo "$SENTRY_VERIFY_INTERVAL_SEC" | grep -E '^[0-9]+$' >/dev/null 2>&1 || SENTRY_VERIFY_INTERVAL_SEC=5
          attempts=0
          release_json=""
          # Up to 60s (12 * 5s) for release visibility
          while [ $attempts -lt "$SENTRY_VERIFY_ATTEMPTS" ]; do
            release_json=$(curl -sf -H "Authorization: Bearer ${SENTRY_AUTH_TOKEN}" \
              https://sentry.io/api/0/projects/${SENTRY_ORG}/${SENTRY_PROJECT}/releases/${GIT_SHA}/ || true)
            if [ -n "$release_json" ]; then break; fi
            attempts=$((attempts+1))
            echo "Release not visible yet (attempt $attempts/$SENTRY_VERIFY_ATTEMPTS); waiting $SENTRY_VERIFY_INTERVAL_SEC s..."
            sleep "$SENTRY_VERIFY_INTERVAL_SEC"
          done
          if [ -z "$release_json" ]; then
            echo "Release not found in Sentry after retries."; if [ "$SENTRY_STRICT" = "true" ]; then exit 1; else exit 0; fi
          fi
          # Poll for files list (REST) up to 60s
          file_attempts=0
          files_json=""
          file_count=0
          while [ $file_attempts -lt "$SENTRY_VERIFY_ATTEMPTS" ]; do
            files_json=$(curl -sf -H "Authorization: Bearer ${SENTRY_AUTH_TOKEN}" \
              https://sentry.io/api/0/projects/${SENTRY_ORG}/${SENTRY_PROJECT}/releases/${GIT_SHA}/files/ || true)
            file_count=$(echo "$files_json" | jq 'length' 2>/dev/null || echo 0)
            if [ "$file_count" -gt 0 ]; then
              echo "REST API file enumeration succeeded after $((file_attempts+1)) attempt(s)."
              break
            fi
            file_attempts=$((file_attempts+1))
            echo "REST returned 0 files (attempt $file_attempts/$SENTRY_VERIFY_ATTEMPTS); waiting $SENTRY_VERIFY_INTERVAL_SEC s for processing..."
            sleep "$SENTRY_VERIFY_INTERVAL_SEC"
          done
          echo "REST API reported file count: $file_count"
          # Sanitize file_count numeric
          file_count=$(echo "$file_count" | tr -cd '0-9')
          [ -z "$file_count" ] && file_count=0

          cli_file_count=0
          if [ "$file_count" -eq 0 ] && [ "$SENTRY_FILE_FALLBACK" = "true" ]; then
            echo "Attempting CLI fallback listing..."
            # Try JSON output first; if unsupported, parse plain text.
            if npx @sentry/cli releases files "$GIT_SHA" list --json > cli_files.json 2>/dev/null; then
              cli_file_count=$(jq 'map(select(.name | test("\\.map$"))) | length' cli_files.json 2>/dev/null || echo 0)
              echo "CLI JSON fallback detected $cli_file_count map files"
              if [ "$SENTRY_DEBUG" = "true" ]; then echo "CLI JSON (truncated names):"; jq '.[].name' cli_files.json; fi
            else
              # Plain listing fallback
              plain_listing=$(npx @sentry/cli releases files "$GIT_SHA" list 2>/dev/null || true)
              echo "$plain_listing" > cli_files.txt
              cli_file_count=$(echo "$plain_listing" | grep -E '\\.map$' | wc -l | tr -d ' ' || echo 0)
              if [ "$SENTRY_DEBUG" = "true" ]; then echo "CLI Plain listing:"; cat cli_files.txt; fi
              echo "CLI plain fallback detected $cli_file_count map files"
            fi
          fi
          # Sanitize cli_file_count
          cli_file_count=$(echo "$cli_file_count" | tr -cd '0-9')
          [ -z "$cli_file_count" ] && cli_file_count=0

          effective_count=$file_count
          if [ "$effective_count" -eq 0 ] && [ "$cli_file_count" -gt 0 ]; then
            echo "WARNING: REST files endpoint returned 0 but CLI shows $cli_file_count map files. Treating as success (processing lag)."
            effective_count=$cli_file_count
          fi
          if [ "$effective_count" -eq 0 ] && [ "${SENTRY_UPLOAD_BUNDLED_COUNT}" -gt 0 ]; then
            echo "WARNING: REST & CLI returned 0 but upload step reported ${SENTRY_UPLOAD_BUNDLED_COUNT} bundled files. Trusting upload success (artifact bundle)."
            effective_count=${SENTRY_UPLOAD_BUNDLED_COUNT}
          fi
          if [ "$effective_count" -eq 0 ] && [ -d dist ]; then
            dist_map_count=$(find dist -type f -name '*.js.map' | wc -l | tr -d ' ')
            if [ "$dist_map_count" -gt 0 ]; then
              echo "WARNING: Using local dist map count ($dist_map_count) as final fallback."; effective_count=$dist_map_count; fi
          fi

          if [ "$SENTRY_DEBUG" = "true" ]; then
            echo "Effective file count: $effective_count (REST=$file_count CLI=$cli_file_count)"
          fi
          if [ "$SENTRY_DEBUG" = "true" ]; then
            echo '--- RELEASE JSON (truncated) ---'
            echo "$release_json" | jq '{version, dateCreated, dateReleased, files: (.files | length)}'
            echo '--- FILE LIST ---'
            echo "$files_json" | jq '.[].name'
          fi
          if [ "$effective_count" -eq 0 ]; then
            echo "No source map files discovered via REST or CLI fallback."; if [ "$SENTRY_STRICT" = "true" ]; then exit 1; fi
          else
            echo "Verification succeeded with $effective_count source map file(s)."
          fi
          {
            echo "# Sentry Source Map Verification";
            echo "Commit: $GIT_SHA";
            echo "REST file count: $file_count";
            echo "CLI file count: $cli_file_count";
            echo "Upload bundled count: ${SENTRY_UPLOAD_BUNDLED_COUNT}";
            echo "Effective count: $effective_count";
            echo "Verify attempts: $SENTRY_VERIFY_ATTEMPTS";
            echo "Verify interval (s): $SENTRY_VERIFY_INTERVAL_SEC";
            if [ "$file_count" -eq 0 ] && [ "$cli_file_count" -gt 0 ]; then
              echo "Note: REST returned 0; CLI fallback used (likely processing lag).";
            fi
            if [ "$file_count" -eq 0 ] && [ "$cli_file_count" -eq 0 ] && [ "${SENTRY_UPLOAD_BUNDLED_COUNT}" -gt 0 ]; then
              echo "Note: REST & CLI returned 0; trusted upload bundle count.";
            fi
            if [ "$file_count" -eq 0 ] && [ "$cli_file_count" -eq 0 ] && [ "${SENTRY_UPLOAD_BUNDLED_COUNT}" -eq 0 ]; then
              echo "Note: All remote counts zero; local dist fallback may have been applied.";
            fi
            echo "Strict mode: $SENTRY_STRICT";
            echo "CLI fallback enabled: $SENTRY_FILE_FALLBACK";
          } >> "$GITHUB_STEP_SUMMARY"
