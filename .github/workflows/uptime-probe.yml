name: uptime-probe

on:
  schedule:
    - cron: '*/5 * * * *' # Every 5 minutes
  workflow_dispatch: {}

permissions:
  contents: read
  issues: write

jobs:
  probe:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Probe production
        id: probe
        run: |
          URL=https://theporadas.com
          STATUS=$(curl -IsS --max-time 10 "$URL" | head -n 1 | awk '{print $2}') || STATUS=0
          echo "status=$STATUS" >> $GITHUB_OUTPUT
          if [ "$STATUS" -eq 200 ] || [ "$STATUS" -eq 301 ] || [ "$STATUS" -eq 302 ]; then
            echo "OK $STATUS"; exit 0; fi
          echo "Unexpected status: $STATUS" >&2; exit 1
      - name: Create/append outage issue
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const status = process.env.STATUS;
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'uptime'
            });
            let issue = issues.find(i => i.title.startsWith('Uptime outage'));
            if (!issue) {
              issue = (await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `Uptime outage detected status=${status}`,
                body: 'Automated uptime probe failing. Investigate edge/site availability.',
                labels: ['uptime']
              })).data;
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `Another failure observed status=${status}`
              });
            }
        env:
          STATUS: ${{ steps.probe.outputs.status }}
